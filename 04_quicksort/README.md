# Notes for 04_quicksort

## 分治法
1. 分治法(Devide and conquer, D&G)是递归式的问题解决方法。
2. **分治法**解决问题分为2步:
   1. 找出简单的基线条件(base case);
   2. 不断将缩小问题的规模，直到符合基线条件。
3. 欧几里得算法(找出最大方块)。
4. 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。
5. 函数式编程语言Haskell中没有循环语句，递归就起了很重要的作用(递归可以替代循环)。
6. 判断语句的条件中不应包含递归成分(可能导致超过recursion limit)；为避免出错，过程中应尽量不要改变列表(pop,remove)。
7. 二分查找也是一种分治法，基线条件是数组中含0个元素(low>high)，递归条件则是数组中至少含有一个元素(low<=high)。

## 快速排序
1. **快速排序**的基本步骤：
  - 选择基准值(pivot);
  - 对数组进行分区(partitioning)，分成大于基准值的元素和小于基准值的元素，及基准值本身；
  - 对两边的分区进行快速排序(分治D&C)。 
2. 归纳证明(通常与分治法协同合作)分为两步：
  - 基线条件(对0元素或一个元素的数组管用);
  - 归纳条件(如果对一个元素数组管用，对2个元素的数组也管用)。

## 再谈大O表示法
1. 实际的运行时间是$c*n$,其中$c$是一次操作花费的固定时间常量，而$n$则表示操作数。**在大O运行时间不同时，常量不重要**(增速的重要性远超过常量)；在大O运行时间相同时，才考虑常量，因此快速排序和合并排序大O时间一致($O(log n)$)，快速排序时间常量小，故而选择快速排序。
2. 快速排序的大O运行时间分为平均情况和最糟情况，遇上平均情况的概率比最糟情况大得多。**大O运行时间=调用栈高*每层的运行时间。**
  - 平均情况(最佳情况):每次都随机选择一个元素做基准值，$O(log n)*O(n) = O(nlog n)$；
  - 最糟情况：有序数组的第一个元素作为基准值,$O(n)*O(n) = O(n^2)$,与第一章的大O表示最糟情况不一样，这里的最糟情况不能代表大多数。
