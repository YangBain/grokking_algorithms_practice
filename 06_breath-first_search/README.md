# Notes for 06_breath-first_seach

## 最短路径问题

1. **最短路径问题**(shortest-path problem)，找出两样东西之间的最短距离。如国际象棋中最少走多少步可以获胜，或找出两地之间的最少换乘路线。
2. **广度优先搜索**(Breath-Fisrt Search, BFS)是用来解决最短路径问题的算法。
3. 解决最短路径问题的两个步骤：
   1. 用图建立问题模型；
   2. 用广度优先搜索解决问题。

## 图

1. **图**(graph)由*节点*(node)和*边*(edge)组成。
2. 图用于模拟一组连接关系。
3. 图分为有向图(directed graoh)和无向图(undirected graph)。
4. *邻居*：有向图中的关系是单向的，如A->B,则B是A的邻居，而A不是B的邻居。无向图中没有箭头，直接相连的节点互为邻居。

## 广度优先搜索

1. *广度优先搜索*是应用于*图*的查找算法。用于解决两类问题：
   - 从节点A，有到节点B的路径吗？
   - 从节点A到节点B，哪条路径最短？
2. 广度优先搜索，从起点开始，先搜索通过一条边直接连接的节点(一度关系)，再搜索两条边可以到达的节点(二度关系)，依次类推。
3. 要实现广度优先搜索，需要将一度关系节点先加入查找名单，二度关系节点后加入查找名单。用于实现按添加顺序搜索的数据结构是**队列**(queue)，否则可能找到的不是最短路径。
4. 队列只支持两种操作：*入队*和*出队*。**回顾**：栈支持的两种操作是压入和弹出(其实队列中的操作也会被叫做压入和弹出)。
5. 队列是一种*先进先出*(First In First Out, FIFO)的数据结构。而栈是一种*后进先出*(Last In First Out, LIFO)的数据结构。
6. 队列和栈都是其中元素不能被随机访问的数据结构。队列中谁可以被访问由谁已出队来决定，栈中谁可以被访问由谁被弹出决定。

## 算法实现

1. **图就是节点到节点的映射**。所以图可以用散列表来表示。邻居用列表表示。
2. Python中队列用双端队列`deque`实现，双端队列只从一端出队，另一端入队就是正常队列。
3. 对于检查过的人不能再重复搜索，否则可能导致无限循环。
4. 广度优先搜索的运行时间是*O(V+E)*，其中*V*(Vertice)为顶点数，*E*为边数。按边数维护搜索队列，按节点个数维护已搜索列表。

## 扩展

1. 如果任务A依赖于任务B，在列表中任务A就必须在B后。这称为**拓扑排序**。可用于创建有序的任务列表。
2. 树(Tree)是一种特殊的图，没有向后指的边。

